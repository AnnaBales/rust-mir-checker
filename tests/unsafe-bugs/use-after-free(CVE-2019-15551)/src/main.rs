// Proof-of-concept of CVE-2019-15551

unsafe fn deallocate<T>(ptr: *mut T, capacity: usize) {
    let _vec: Vec<T> = Vec::from_raw_parts(ptr, 0, capacity);
}

fn bug(n: i32, v: &mut Vec<u32>) {
    if n < 0 {
        // Do something
    }
    // Fix
    // else {
    //     return;
    // }
    unsafe {
        deallocate(v.as_mut_ptr(), v.len());
    }
}

fn main() {
    let mut v = vec![1, 2, 3, 4, 5];
    bug(1, &mut v);
}
